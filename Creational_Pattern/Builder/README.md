# 生成器

### **假装有介绍**

有时候在开发的时候会有这样一种情况：你需要初始化一个对象，然而这个对象的初始化却十分麻烦，他可能需要很多的成员变量或是已经完成初始化的对象来完成他的初始化。有时候甚至不能连续的完成初始化，就好像一条巨大的生产线。这种对象创建还是小事，可有时候这种对象的某些属性并不需要去执行初始化，也就是这种对象的属性并非必需。那如果对每种构造的对象进行细分并为这些对象分别创建一个类或者专门为这些情况去重载构造函数的话，代码量将会是可想而知的增长。这时候不妨设计一名建筑师，让它来专门完成这些对象的创建。这名建筑师就是生成器（Builder）

***

### **这也真没啥例子好讲的**

个人觉得生成器模式其实比两个工厂方法更加容易理解：你只需要将这些客制化的对象看作是一堆零件的堆叠，然后根据具体情况去选择合适的零件完成它的构造即可。那么生成器模式实际上就是封装了对这种对象各个零件拆装操作的独立对象。在开发的时候你只需要将具体的构造过程利用生成器对象暴露的接口对生成器内部的产品对象进行调整，最后由生成器返回已经构造完成的所需产品对象即可。

如果确定了在开发过程中的对象会有几种具体的典型的类型，则不妨创建一个主管类，这个主管类可以严格固定地执行某些生成器对象生成步骤用来生成这些具体类型的产品对象。虽然这个主管类并不一定是必需的，但是如果你的代码中存在着重复调用生成器的某些例行构造时，使用主管类可以很好的完成这部分代码的复用，而且不会向客户端暴露这些例行构造的产品的具体构造逻辑。 

***

### **存在的意义**

当你像创建不同形式的同种产品时，使用生成器模式可以有效防止重复重载构造函数来应对多种不同类型的产品对象，也可以使您在创建对象的过程中延迟部分步骤的进行。

***

### **实现方式**

1. 首先需要确定创建一个具备所有属性的产品所需要的创建步骤，并实现这些步骤方法。

2. 为每个生成器类声明返回产品对象的方法。

3. 声明一个抽象工厂接口，并且在接口中声明所有抽象产品的构造方法。

4. 在使用产品的代码中，按照具体创建步骤分别调用生成器类的步骤方法，然后调用返回产品对象的方法即可。

***

### **可能存在的问题**

几乎所有设计模式的通病就是让代码结构更加复杂了，但是这也明显是理所当然的事。