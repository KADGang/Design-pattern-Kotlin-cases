# 抽象工厂模式

### **假装有介绍**

从工厂模式里我们可以知道，如果需要一个同类型的产品而不确定究竟何时需要选择何种产品时，我们可以对其使用工厂模式。然而工厂模式只考虑生产同等级（同类型）的产品，但是在现实生活中很多工厂并不会只制造一种产品，而是生产一系列产品。实际开发过程中我们可能也会遇到这种问题：某些情况下我们需要针对某些特定情况统一创建一系列不同等级（不同类型）的产品。如果在这种情况下依然针对每一等级的产品去使用工厂模式的话，那么工厂方法的代码将会变得臃肿不堪。此时不妨试试抽象工厂模式。

***

### **打包甜品！**

现在来到了稍微现实一点的世界（但是也挺抽象的）：众所周知，绝大部分甜品店不会只制作一种甜品。同一家店完全有可能既生产马卡龙也生产泡芙舒芙蕾等等等等。这时候大街上有A、B两家甜品店，A店的甜品口味更加清甜不腻口，然而B店的甜品口感更加丝滑舒畅。这两家店水火不容，尽管售卖的商品类型完全一致，但是都各自认为自己家的甜品才是整条街最好的甜品，并且觉得对方的甜品绝对不配跟自己家的放在一起。如果发现你今天买了对家的甜品，那么他们将会拒绝向你售卖自家的甜品！（抽象的地方来了）并且更恶劣的是，他们的甜品都不是单卖的！还是所有产品各一个捆绑售卖甜品包！（编不下去了）那么这时候你就不得不根据今天的心情来选择到底是要去口味更佳的A店还是口感更好的B店买打包的甜品了。

那么在这个例子中，同类型的产品（比如他们共同售卖的泡芙）被称为同等级的产品。然而他们每个店分别售卖的一系列产品（整个甜品包中的每一份甜品）被称为产品族。

***

### **存在的意义**

在实际的开发中，如果我们所需的产品中有多于一个的产品族，并且我们在同一时刻只能消费某一族的产品，而消费哪一族产品需要根据情况来判断时，则可以使用抽象工厂模式。

***

### **实现方式**

1. 首先需要确定每个产品族所有同等级产品遵循同一个接口，这个接口里必须声明所有产品都需要或有可能执行的方法。

2. 为每种产品设计一个子类，并实现产品的接口。

3. 声明一个抽象工厂接口，并且在接口中声明所有抽象产品的构造方法。

4. 为每一个产品族实现都实现一个具体工厂类，所有具体工厂类必须实现抽象工厂接口。

5. 在使用产品的代码中，需要根据具体使用情况去初始化相应产品族对应的具体工厂类。然后使用该工厂类去进行相应产品族中各个产品的生产与消耗。

***

### **可能存在的问题**

如果你的产品族种类过大，那么你的代码就更加臃肿了。。。